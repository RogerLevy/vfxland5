public

trait: %dltree
    is-a %iterable
    is-a %lifo

    prop parent   :ref %dltree
    prop lowest   :ref %dltree
    prop highest  :ref %dltree 
    prop prev     :ref %dltree  
    prop next     :ref %dltree

    :: insert-under ( dltree - ) stub ; 
    :: insert-over ( dltree - ) stub ; 
trait;

: dlremove ( dltree -- )
    {: n | p :}
    n -> parent @ to p
    p -exit
    0 n -> parent !
    -1 p >item-count +! 
    p -> lowest @ p -> highest @ = if
        n p -> lowest @ = if
            0 dup p -> lowest ! p -> highest !
        exit then
        -1 abort" DLREMOVE : Corrupt dltree!"
    else
        n p -> lowest @ = if
            0 n -> next @ -> prev !
            n -> next @ p -> lowest !
            0 dup n -> prev ! n -> next !
        exit then
        n p -> highest @ = if
            0 n -> prev @ -> next !
            n -> prev @ p -> highest !
            0 dup n -> prev ! n -> next !
        exit then
        n -> next @ n -> prev @ -> next !
        n -> prev @ n -> next @ -> prev !
        0 dup n -> prev ! n -> next !
    then ;

: (dlinit)  ( dltree parent -- )
    locals| p n |
    n dup p -> lowest ! p -> highest !
    p n -> parent ! ;

: dlpush  ( dltree parent -- )
    2dup = abort" DLPUSH : Attempt to add dltree to itself." 
    over dlremove
    1 over >item-count +! 
    dup -> lowest @ 0= if  (dlinit)  exit  then
    locals| p n |
    n p -> highest @ -> next !
    p -> highest @ n -> prev !
    n p -> highest !
    p n -> parent ! ;

: dlunshift  ( dltree parent -- )
    2dup = abort" DLUNSHIFT : Attempt to add dltree to itself." 
    over dlremove
    1 over >item-count +! 
    dup -> lowest @ 0= if  (dlinit)  exit  then
    locals| p n |
    p -> lowest @ n -> next !
    n p -> lowest @ -> prev ! 
    n p -> lowest !
    p n -> parent ! ;

: dlinsert-over  ( dltree dest -- )
    2dup = if 2drop exit then
    dup -> parent @ 0= abort" DLINSERT-OVER : Target dltree has no parent."
    over dlremove 
    dup -> next @ 0= if  -> parent @ dlpush exit  then
    1 over >parent @ >item-count +! 
    dup -> next @ locals| neighbor dest src |
    src dest -> next !
    dest src -> prev !
    neighbor src -> next !
    src neighbor -> prev !
    dest -> parent @ src -> parent ! ;

: dlinsert-under  ( dltree dest -- )
    2dup = if 2drop exit then
    dup -> parent @ 0= abort" DLINSERT-UNDER : Target dltree has no parent."
    dup >prev @ ?dup if
        nip dlinsert-over
    else
        >parent @ dlunshift
    then ;

fast{
borrow array3>> enough-flag
: _dleach ( xt dltree - ) ( ... dltree - ... )
    >lowest @ dup if
        begin dup enough-flag @ not and while
            dup >next @ >r  swap dup >r execute  r> r> 
        repeat
        2drop
    else ( xt 0 ) 2drop then ;

: dleach  ( xt dltree -- ) ( dltree - )
    over 0= if 2drop exit then
    enough-flag @ >r enough-flag off
    ['] _dleach catch
    r> enough-flag !
    throw ;

: (dlorphan)  0 dup next ! dup prev ! parent ! ;

: dlclear  ( dltree -- )
    -> lowest @ ?dup if
        {
            begin  me while
                next @  (dlorphan)  to me
            repeat
        }
        0 dup lowest ! highest !
        0 item-count !
    then ;

borrow array3>> _?bounds

private

: _nth-child ( n - dltree )
    _?bounds
    dup item-count @ 1 - = if drop highest @ exit then
    lowest @ 
    swap 0 max for -> next @ loop ;

public

: descendant? ( dltree1 dltree2 - flag )
    swap {
        begin parent @ dup while
            over = if   } drop -1   exit then
            parent @ to me
        repeat nip ( 0 )
    } ;
fast}


%dltree :: el@ ( i - val ) _nth-child ;
%dltree :: el? ( i - val ) _nth-child .summary ;

%dltree :: push ( item - ) me dlpush ; 
%dltree :: pop ( - item ) highest @ dup 0= abort" DLTREE:POP : Underflow." dup dlremove ; 
%dltree :: unshift ( item - ) me dlunshift ; 
%dltree :: shift ( - item ) lowest @ dup 0= abort" DLTREE:SHIFT : Underflow." dup dlremove ; 
%dltree :: vacate ( - ) me dlclear ;

%dltree :: each ( xt - ) me dleach ;

%dltree :: insert-under ( dltree - ) me dlinsert-under ;
%dltree :: insert-over ( dltree - ) me dlinsert-over ;

%dltree :: remove ( dltree - ) 
    dup >parent @ me <> abort" DLTREE:REMOVE : Not my child."
    dlremove ;

%dltree :: removeat ( i - ) 
    _nth-child dlremove ;

%dltree :: insertat ( dltree i - ) 
    dup me #items <> if
        _nth-child insert-under
    else
        drop me push
    then ;

%dltree :: indexof ( dltree - )
    dup >parent @ me <> abort" DLTREE:INDEXOF : Not my child."
    0 swap begin >prev @ ?dup while 1 u+ repeat ;

%dltree :: peek ( - item ) 
    highest @ dup 0= abort" DLTREE::PEEK : Empty." ;


aka #children #items