require %idir%/checks.vfx
require %idir%/utilities.vfx
require %idir%/traits.vfx
require %idir%/asset.vfx

65536 ?constant #bitmaps

class: %bitmap
    %asset derive
    is-a %saveable
    is-a %_bitmap
    prop albmp
    prop touched
class;

%bitmap object dummy.bmp
|| : dummies,  #bitmaps for dummy.bmp , loop ;

create bitmaps %addr array{ dummies, array} drop

: bitmap@  $FFFF and bitmaps el@ ;
: bitmap!  $FFFF and bitmaps el! ;

variable next-bmp#  1 next-bmp# !

: alloc-bmp# ( - bmpid ) next-bmp# @   1 next-bmp# +! ;
: add-bitmap ( bitmap - bmpid ) 
    alloc-bmp# >r 
    r@ over >bmp !
    r@ bitmap! r> ;

: id>albmp ( bmpid - albmp ) 
    bitmap@ -> albmp @ ;

: id>bmp ( bmpid - bitmap ) 
    bitmap@ ;

: albmp>id ( albmp - bmpid | 0 )
    \ Find bitmap ID given an Allegro bitmap pointer
    \ Returns 0 if not found
    next-bmp# @ 1 do
        dup i bitmap@ -> albmp @ = if
            drop i unloop exit
        then
    loop
    drop 0 ;

: bmp>parent ( bmpid - bmpid' )  
    id>albmp al_get_parent_bitmap albmp>id ;

: is-subbmp? ( bmpid - flag )
    id>albmp dup -exit al_is_sub_bitmap 0<> ;

: ?bmp>parent ( bmpid - bmpid|bmpid' )
    dup is-subbmp? if bmp>parent then ;

: bitmap-file ( bmpid - a n ) 
    ?bmp>parent id>bmp -> srcpath$ count ;

\ : ?nullbmp  dup 0= abort" BITMAP-FILE : Bitmap is null!" ;
\ : ?subbmp  dup al_is_sub_bitmlap if al_get_parent_bitmap then ;

: wrap-bitmap ( albmp - bitmap )
    %bitmap make { albmp ! me } ;

: bmpwh ( bmpid - w h )
    id>albmp ?dup if dup albmpw swap albmph else 0 0 then ;

: bmpw ( bmpid - w )
    bmpwh drop ;

: bmph ( bmpid - h )
    bmpwh nip ;

: bmpxy ( bmp - x y ) 
    id>albmp dup al_get_bitmap_x swap al_get_bitmap_y ;

: put ( bmpid - ) 
    \ draw a sprite; takes a bitfield $F000IIII 
    ?dup -exit
    dup id>albmp swap 24 rshift draw-bitmap ;

: cput ( bmpid - ) 
    \ draw sprite with center as the origin
    dup dup bmpwh -2 -2 2/ +at put bmpwh 2 2 2/ +at ;

%bitmap :: save
    touched @ -exit
    bmp @ id>albmp 0= ?exit  \ Skip if no valid Allegro bitmap
    bmp @ is-subbmp? if
        \ For sub-bitmaps, touch parent and exit
        touched off
        bmp @ bmp>parent ?dup if
            id>bmp >touched on
        then
        exit
    then
    \ Normal bitmap - save it
    touched off
    bmp @ bitmap-file expand >zpad   bmp @ id>albmp al_save_bitmap
        0= abort" Error saving bitmap"
    bmp @ bitmap-file f" Saved bitmap to %s" type cr ;

: save-bitmaps
    \ Do 2 passes - allows touched sub-bitmaps to touch
    \ their parent bitmaps which are then saved once in the second pass
    2 for ['] save bitmaps each loop ;


\ =============================================================================
\ Backward compatibility
\ =============================================================================

\ aka >albmp id>albmp
aka bmptotem id>bmp
